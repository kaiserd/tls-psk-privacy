<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY rfc2119 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'>
<!ENTITY rfc8446 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml'>

]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>

<!-- Expand crefs and put them inline -->
<?rfc comments='yes' ?>
<?rfc inline='yes' ?>

<rfc category="std"
     docName="draft-kaiser-tls-psk-privacy-00"
     ipr="trust200902">

<front>
    <title abbrev="TLS 1.3 PSK Priv">
      Privacy-Preserving PSK-ID for TLS 1.3
    </title>

   <author fullname="Daniel Kaiser" initials="D." surname="Kaiser">
      <organization>University of Luxembourg</organization>
      <address>
        <postal>
          <street>6, avenue de la Fonte</street>
          <city>Esch-sur-Alzette</city>
          <code>4364</code>
          <region></region>
          <country>Luxembourg</country>
        </postal>
        <email>daniel.kaiser@uni.lu</email>
        <uri>https://secan-lab.uni.lu/</uri>
      </address>
    </author>

   <author fullname="Christian Huitema" initials="C." surname="Huitema">
      <organization>Private Octopus Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Friday Harbor</city>
          <code>98250</code>
          <region>WA</region>
          <country>U.S.A.</country>
        </postal>
        <email>huitema@huitema.net</email>
        <uri>http://privateoctopus.com/</uri>
      </address>
    </author>


    <date year="2019" />

    <abstract>
<t>
  This document specifies a new extension, eid_pre_shared_key, introducing
  privacy-preserving ephemeral identifiers as PSK identities, which are time-based and only interpretable by an authorized peer.
</t>

<t>
  The new extension allows the TLS 1.3 handshake to
  support private mutual authentication, meaning the endpoints authenticate each other
  while only disclosing their identities to their respective peer if the peer actually is who it claims to be.
  Private mutual authentication is especially desired for privacy preserving applications in which devices can act as both client and server.
</t>
    </abstract>
</front>

<middle>
<section title="Introduction">
<t>
  TLS 1.3 <xref target="RFC8446" /> specifies how session keys can be derived from Pre Shared Keys (PSK). In that mode,
  the PSK proposed by clients and selected by servers are identified by PSK Identifiers. The specification envisages
  two types of PSK: keys that are obtained during a session establishment and can be used for session resumption;
  and keys that are established out of band. The  latter type of key is typically valid for a significant time. We
  are concerned that if the key identifier remains constant for a long period of time, it can be used for
  tracking the client and server.
</t>

<t>
  This document defines ephemeral PSK identifiers for TLS 1.3 <xref target="RFC8446" />.
  These identifiers allow private mutual authentication when using the PSK based handshake.
</t>

<t>
  Besides PSK indentifiers, there may be other data sent during the handshake that could be used to
  track client or servers. Obviously, the handshake privacy will only be achieved if the clients and
  servers refrain from providing such data, as explained in <xref target="mess-id" />.
</t>

<section title="Requirements">
<t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
  document are to be interpreted as described in <xref target="RFC2119" />.
</t>
</section>
</section>

<section title="TLS 1.3 Handshake Supporting Privacy-Preserving PSK-IDs" anchor="priv-auth">

<t>
  The "eid_pre_shared_key" extension specified in <xref target="eid-psk-extension" /> introduces privacy-preserving ephemeral PSK-IDs.
</t>

<t>
  A client that wants to negotiate a TLS 1.3 session using ephemeral PSK-IDs
  MUST send an eid_pre_shared_key extension, as defined in <xref target="eid-psk-extension" />.
  It MUST NOT send a pre_shared_key extension.
  [[ TODO: Really? what about using session resumption tickets? These are PSK ID too. Do we want to prevent them? ]]
</t>
<t>
  If private mutual authentication is desired, the client SHOULD NOT send messages or extensions that contain the client's
  identity or data that might allow inferring the client's identity. <xref target="mess-id" /> lists these messages and extensions.
  By sending an eid_pre_shared_key extension, the client indicates that it wants to negotiate in mutual private authentication mode.
</t>

<t>
  A server supporting ephemeral PSK-IDs receiving an eid_pre_shared_key extension MUST send back an eid_pre_shared_key extension
  containing an ephemeral_identity for the chosen PSK.
  It MUST NOT ask the client for a certificate.
  If the server does not support ephemeral PSK-IDs it must abort sending an alert [[TODO: which altert?]].
</t>

<t>
  A server that does not want to disclose its identity to unauthenticated clients MUST
  abort any handshake that does not contain an eid_pre_shared_key extension.
  [[SHOULD it send back an alert? If so, the alert MUST NOT contain traceable information.]]
  [[Really? Suppose the client sends an ESNI encrypted with a key that is only known to authorized clients. Is that forbidden to?]]
</t>

<t>
  The following diagram illustrates a TLS 1.3 handshake using the eid_pre_shared_key extension. The diagram is based on
  the PSK handshake diagram in <xref target="RFC8446" /> Section 2.2.
  The handshake does not comprise any messages or extensions that directly or indirectly hold the identity of either endpoint, e.g. certificates.
</t>

<t>
<figure>
<artwork>
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share*
     | + psk_key_exchange_modes*
     v + eid_pre_shared_key*  --------&gt;
                                               ServerHello  ^ Key
                                              + key_share*  | Exch
                                     + eid_pre_shared_key*  v
                                     {EncryptedExtensions}  ^  Server
                                                            v  Params
                                                 {Finished} ^  Auth
                                                            v
                             &lt;-------- [Application Data*]
Auth ^
     v {Finished}            --------&gt;
       [Application Data]    &lt;-------&gt; [Application Data]
</artwork>
</figure>
</t>

<section title="Messages and Extensions Containing Identifiable Information" anchor="mess-id">
  <t>
    [[TODO]]
    [[Obviously, do not state the server identity in a clear text SNI if server privacy is desired.
    What else? Also, what if servers actually handle multiple services and would like to use the SNI?
    Need to state that the SNI is implied by the selected PSK-ID.]]
  </t>
  <t>
    [[Should we say something about server cert? It is not required in a PSK exchange. It does
    identify the server. But it is sent encrypted, and encryption assumes knowledge of the PSK,
    so there is little risk there.]]
  </t>
  <t>
    Anything else? Fingerprinting through set of extensions?
  </t>
</section>

</section>

<section title="Ephemeral PSK Identity Extension" anchor="eid-psk-extension">

<t>
  As the "extension_data" field of the "pre_shared_key" extension specified in <xref target="RFC8446" /> Section 4.2.11
  is comprised of a "PreSharedKeyExtension",
  the "extension_data" field of the "eid_pre_shared_key" extension specified in this section is comprised of
  an "EIDPreSharedKeyExtension" value, which is defined as:
</t>

<t>
 <figure>
<artwork>
struct {
    opaque ephemeral_identity[hash.length];
} EphemeralPskIdentity;

opaque PskBinderEntry&lt;132..255&gt;;

struct {
    EphemeralPskIdentity ephemeral_identities&lt;7..2^16-1&gt;;
    PskBinderEntry binders&lt;33..2^16-1&gt;;
} OfferedPsks;

struct {
    select (Handshake.msg_type) {
        case client_hello: OfferedPsks;
        case server_hello: uint16 selected_identity;
    };
} EIDPreSharedKeyExtension;
</artwork>
</figure>
</t>

<t>
  Besides different names and semantics, the structural differences between the standard "PskIdentity" struct and
  the "EphemeralPskIdentity" struct defined in this document are as follows.
  (1) The "ephemeral_identity" field has a fixed length corresponding to the output length of the hash function in the
  negotiated cipher suite.
  Further, (2) the "ephemeral_identity" struct does not have an obfuscated_ticket_age field, which is normally used in conjunction with
  PSKs that have been established via a previous certificate based handshake.
  The ephemeral_identity struct is specified in <xref target="eph-id-gen" />.
  The remainder of the values work as defined in <xref target="RFC8446" />.
</t>

<t>
  [[Should we explicitly require externally established keys for the new mode of operation?
  PSKs established via certificates would have lead to a privacy leak in the past...
  If we were to include a ticket age mechanism, we need to care that it does not introduce traceable information.]]
</t>


<section title="Generating Ephemeral PSK Identities" anchor="eph-id-gen">
  <t>
    Ephemeral PSK Identifiers are calculated as follows.
  </t>
<t>
 <figure>
   <artwork>
  timestamp = 64 bit Unix GMT time
  seed = 56 most significant bits of timestamp padded with 0s
  ephemeral_early_secret = HKDF-Extract(PSK, timestamp)
  ephemeral_identity = HKDF-Expand-Label(ephemeral_early_secret,
                                         "eph-id", hash.length)
</artwork>
</figure>
</t>

<t>
  [[For efficiency reasons, we could also use ephemeral_identity = HKDF-Expand-Label(binder_key, "eph-id", hash.length)]] or
  even just HMAC(seed, PSK). But first generating a separate secret fits better into the TLS 1.3 key schedule.]]
</t>

</section>

<section title="Verifying Ephemeral PSK Identities" anchor="eph-id-ver">

<t>
  A server supporting ephemeral PSK-IDs receiving an eid_pre_shared_key extension
  checks whether the provided ephemeral key identities match valid PSKs and if so,
  chooses one of the PSKs and sends back an eid_pre_shared_key extension containing an ephemeral identity for that key.
  The server MUST also take the two surrounding time intervals into consideration when checking ephemeral PSK Identities.
</t>

<t>
  In case of heavily skewed clocks, the connection establishment fails even if both parties hold valid PSKs.
  [[This problem could be mitigated by prepending the seed to the ephemeral identity. However, this mitigation technique would
  allow tracking heavily skewed clocks.]]
</t>

<t>
  Servers SHOULD compute a hash table mapping all ephemeral identities valid in
  the current time interval to the corresponding PSKs.
  Servers SHOULD maintain hash tables for the surrounding time intervals as well.
  This allows checking in O(1) and thus mitigates DoS attacks.
</t>
</section>


</section>

<section title="Security Considerations" anchor="security">
  <t>
    [[TODO]]
  </t>
</section>

<section title="IANA Considerations" anchor="iana">
<t>
    [[TODO]]
</t>
</section>

<section title="Acknowledgments">
    <t>
    </t>
</section>

</middle>

<back>
<references title="Informative References">
  &rfc2119;
  &rfc8446;


</references>
</back>
</rfc>
