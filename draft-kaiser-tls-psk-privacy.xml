<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY rfc2119 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'>
<!ENTITY rfc8446 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml'>

<!ENTITY I-D.ietf-tls-esni PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tls-esni.xml">

]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>

<!-- Expand crefs and put them inline -->
<?rfc comments='yes' ?>
<?rfc inline='yes' ?>

<rfc category="std"
     docName="draft-kaiser-tls-psk-privacy-00"
     ipr="trust200902">

<front>
    <title abbrev="TLS 1.3 PSK Priv">
      Privacy-Preserving PSK-ID for TLS 1.3
    </title>

   <author fullname="Daniel Kaiser" initials="D." surname="Kaiser">
      <organization>University of Luxembourg</organization>
      <address>
        <postal>
          <street>6, avenue de la Fonte</street>
          <city>Esch-sur-Alzette</city>
          <code>4364</code>
          <region></region>
          <country>Luxembourg</country>
        </postal>
        <email>daniel.kaiser@uni.lu</email>
        <uri>https://secan-lab.uni.lu/</uri>
      </address>
    </author>

   <author fullname="Christian Huitema" initials="C." surname="Huitema">
      <organization>Private Octopus Inc.</organization>
      <address>
        <postal>
          <street></street>
          <city>Friday Harbor</city>
          <code>98250</code>
          <region>WA</region>
          <country>U.S.A.</country>
        </postal>
        <email>huitema@huitema.net</email>
        <uri>http://privateoctopus.com/</uri>
      </address>
    </author>


    <date year="2019" />

    <abstract>
<t>
  This document introduces privacy-preserving ephemeral identifiers as PSK identities,
  which are time-based and only interpretable by an authorized peer.
</t>

<t>
  Ephemeral PSK identities allow the TLS 1.3 handshake to
  support private mutual authentication, meaning the endpoints authenticate each other
  while only disclosing their identities to their respective peer if the peer actually is who it claims to be.
  Private mutual authentication is especially desired for privacy preserving applications in which devices can act as both client and server.
</t>
    </abstract>
</front>

<middle>
<section title="Introduction">
<t>
  TLS 1.3 <xref target="RFC8446" /> specifies how session keys can be derived from Pre Shared Keys (PSK). In that mode,
  the PSK proposed by clients and selected by servers are identified by PSK identifiers. The specification envisages
  two types of PSK: keys that are obtained during a session establishment and can be used for session resumption;
  and keys that are established out of band. The  latter type of key is typically valid for a significant time. We
  are concerned that if the key identifier remains constant for a long period of time, it can be used for
  tracking the client and server.
</t>

<t>
  This document defines ephemeral PSK identifiers for TLS 1.3 <xref target="RFC8446" />.
  These identifiers allow private mutual authentication when using the PSK based handshake.
</t>

<t>
  Besides PSK indentifiers, there may be other data sent during the handshake that could be used to
  track client or servers. Obviously, the handshake privacy will only be achieved if the clients and
  servers refrain from providing such data, as explained in <xref target="mess-id" />.
</t>

<section title="Requirements">
<t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
  document are to be interpreted as described in <xref target="RFC2119" />.
</t>
</section>
</section>

<section title="TLS 1.3 Handshake Supporting Privacy-Preserving PSK-IDs" anchor="priv-auth">

<t>
  A client that wants to negotiate a TLS 1.3 session using ephemeral PSK-IDs
  MUST generate an ephemeral PSK identity as defined in <xref target="eph-id-gen" /> and
  send a pre_shared_key extension containing this ephemeral PSK ID.
</t>
<t>
  If private mutual authentication is desired, the client SHOULD NOT send messages or extensions that contain the client's
  identity or data that might allow inferring the client's identity. <xref target="mess-id" /> lists these messages and extensions.
  <!-- By sending an eid_pre_shared_key extension, the client indicates that it wants to negotiate in mutual private authentication mode. -->
  [[TODO: Should there be an indication that lets the server know the client wants to establish a session using ephemeral PSK IDs?
  As currently described, the server needs to check both the standard PSK IDs and the eph ID table.]]
</t>

<t>
  A server supporting ephemeral PSK-IDs receiving a pre_shared_key extension
  containing an ephemeral PSK identity for the chosen PSK will process it according to <xref target="eph-id-ver" />.
  If the server does not have a matching PSK, it will proceed in same way as when not having a PSK matching any standard PSK ID.
  It MUST NOT ask the client for a certificate.
</t>

<t>
  A server that does not want to disclose its identity to unauthenticated clients MUST
  abort any handshake that neither contains
  <list style="numbers">
    <t>
      a valid ephemeral PSK ID, nor
    </t>
    <t>
      an ESNI encrypted with a key that is only known to authorized clients as described in <xref target="I-D.ietf-tls-esni" />.
      [[However, other clients in possession of this key will learn about the connection establishment.]]
    </t>
  </list>
  [[SHOULD it send back an alert? If so, the alert MUST NOT contain traceable information.
  The server could react in the same as when none of the PSK-IDs offered by the client match.]]
</t>

<t>
  The following diagram illustrates a TLS 1.3 handshake using the pre_shared_key extension. The diagram is based on
  the PSK handshake diagram in <xref target="RFC8446" /> Section 2.2.
  The handshake does not comprise any messages or extensions that directly or indirectly hold the identity of either endpoint, e.g. certificates.
  The new semantics of the identify field within the pre_shared_key extension are specified in <xref target="eph-id" />.
</t>

<t>
<figure>
<artwork>
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share*
     | + psk_key_exchange_modes*
     v + pre_shared_key*  --------&gt;
                                               ServerHello  ^ Key
                                              + key_share*  | Exch
                                     + pre_shared_key*  v
                                     {EncryptedExtensions}  ^  Server
                                                            v  Params
                                                 {Finished} ^  Auth
                                                            v
                             &lt;-------- [Application Data*]
Auth ^
     v {Finished}            --------&gt;
       [Application Data]    &lt;-------&gt; [Application Data]
</artwork>
</figure>
</t>

<section title="Session Tickets" anchor="tickets">

  <t>
    As described in <xref target="RFC8446" /> Section 4.6.1.,
    the server can provide the client with session tickets, each of which is associated with a newly created separate PSK.
    Using session tickets enables unlinkablity of session establishment requests within a single timeframe.
    Clients SHOULD send a ticket only once, as messages containing the same ticket are linkable.
    Servers MUST accept a ticket only for a single connection establishment.
  </t>

</section>

<section title="Messages and Extensions Containing Identifiable Information" anchor="mess-id">
  <t>
    [[TODO]]
    [[Obviously, do not state the server identity in a clear text SNI if server privacy is desired.
    What else? Also, what if servers actually handle multiple services and would like to use the SNI?
    Need to state that the SNI is implied by the selected PSK-ID.]]
  </t>
  <t>
    [[Should we say something about server cert? It is not required in a PSK exchange. It does
    identify the server. But it is sent encrypted, and encryption assumes knowledge of the PSK,
    so there is little risk there.]]
  </t>
  <t>
    Anything else? Fingerprinting through set of extensions?
  </t>
</section>

</section>

<section title="Ephemeral PSK Identities" anchor="eph-id">

  <t>
    This document does not introduce new TLS extensions
    which allows easily upgrading existing implementations.
    Ephemeral PSK identities are sent via the PreSharedKeyExtension
    specified in <xref target="RFC8446" /> Section 4.2.11.
    Only the semantics of the identity field of the PskIdentity struct changes.
  </t>

<t>
<figure>
<artwork>
  struct {
    opaque identity&lt;1..2^16-1&gt;;
    uint32 obfuscated_ticket_age;
  } PskIdentity;
</artwork>
</figure>
</t>

<t>
 <!-- in the context of private authentication as specified in this document -->
  identity: an ephemeral identifier for a PSK (as defined in <xref target="eph-id-gen" />)
  or a single-use ticket (as defined in <xref target="RFC8446" /> Appendix B.3.4.).
</t>


  <t>
    [[We also discussed introducing a new eid_pre_shared_key extension;
    it would make the use of ephemeral PSK identities explicit and allow
    clients to indicate their wishes to use private authentication.]]
  </t>


<section title="Generating Ephemeral PSK Identities" anchor="eph-id-gen">


  <t>
    Ephemeral PSK Identifiers are calculated as follows.
  </t>
<t>
 <figure>
   <artwork>
  timestamp = 64 bit Unix GMT time
  seed = 56 most significant bits of timestamp padded with 0s
  ephemeral_early_secret = HKDF-Extract(PSK, seed)
  ephemeral_identity = HKDF-Expand-Label(ephemeral_early_secret,
                                         "eph-id", hash.length)
</artwork>
</figure>
</t>

<t>
  [[For efficiency reasons, we could also use ephemeral_identity = HKDF-Expand-Label(PSK, seed, "eph-id", hash.length),
  which would be similar to establishing session tickets;
  or even just HMAC(seed, PSK). But first generating a separate secret fits better into the TLS 1.3 key schedule.]]
</t>

</section>

<section title="Verifying Ephemeral PSK Identities" anchor="eph-id-ver">

<t>
  A server supporting ephemeral PSK-IDs receiving a pre_shared_key extension
  checks
  <list style="numbers">
  <t>
    if the provided key identities match valid standard PSKs and if not,
  </t>
  <t>
    if the provided key identities are valid ephemeral PSKs.
  </t>
  </list>
  If a match has been found, the server sends back a pre_shared_key extension containing the respective PSK Identity.
  If the server operates in private authentication mode only, it will not have standard PSK IDs
  [[an exception to this are standard PSK IDs associated with ESNI keys.]].
</t>
  
<t>
  When checking the validity of ephemeral PSK identities,
  the server MUST also take the two surrounding time intervals into consideration when checking ephemeral PSK Identities.
</t>

<t>
  In case of heavily skewed clocks, the connection establishment fails even if both parties hold valid PSKs.
  [[This problem could be mitigated by prepending the seed to the ephemeral identity. However, this mitigation technique would
  allow tracking heavily skewed clocks.]]
</t>

<t>
  Servers SHOULD compute a hash table mapping all ephemeral identities valid in
  the current time interval to the corresponding PSKs.
  Servers SHOULD maintain hash tables for the surrounding time intervals as well.
  This allows checking in O(1) and thus mitigates DoS attacks.
</t>
</section>


</section>

<section title="Security Considerations" anchor="security">
  <t>
    [[TODO]]
  </t>
</section>

<section title="IANA Considerations" anchor="iana">
<t>
    [[TODO]]
</t>
</section>

<section title="Acknowledgments">
    <t>
    </t>
</section>

</middle>

<back>
<references title="Normative References">
  &rfc2119;
  &rfc8446;


</references>
<references title="Informative References">
   &I-D.ietf-tls-esni;

</references>
</back>
</rfc>
